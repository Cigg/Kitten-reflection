precision mediump float;

varying vec4 vWorldSpaceNormal;
varying vec2 vVertexTextureCoord;
varying vec4 vWorldSpaceCoord;
varying vec3 vModelSpaceCoord;

uniform mat4 uMMatrix;
uniform mat4 uPMatrix;
uniform mat4 uVMatrix;
uniform vec3 uEyeCoord;
uniform mat4 uReflectionViewMatrix;
uniform sampler2D uReflectionTexture;
uniform float uTime;

mat2 m2 = mat2(1.6,-1.2,1.2,1.6);

//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
	return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
	return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
	return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) {
  	const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
	                  0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
	                 -0.577350269189626,  // -1.0 + 2.0 * C.x
	                  0.024390243902439); // 1.0 / 41.0
	// First corner
	vec2 i  = floor(v + dot(v, C.yy) );
	vec2 x0 = v -   i + dot(i, C.xx);

	// Other corners
	vec2 i1;
	//i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
	//i1.y = 1.0 - i1.x;
	i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
	// x0 = x0 - 0.0 + 0.0 * C.xx ;
	// x1 = x0 - i1 + 1.0 * C.xx ;
	// x2 = x0 - 1.0 + 2.0 * C.xx ;
	vec4 x12 = x0.xyxy + C.xxzz;
	x12.xy -= i1;

	// Permutations
	i = mod289(i); // Avoid truncation effects in permutation
	vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

	vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
	m = m*m ;
	m = m*m ;

	// Gradients: 41 points uniformly over a line, mapped onto a diamond.
	// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

	vec3 x = 2.0 * fract(p * C.www) - 1.0;
	vec3 h = abs(x) - 0.5;
	vec3 ox = floor(x + 0.5);
	vec3 a0 = x - ox;

	// Normalise gradients implicitly by scaling m
	// Approximation of: m *= inversesqrt( a0*a0 + h*h );
	m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

	// Compute final noise value at P
	vec3 g;
	g.x  = a0.x  * x0.x  + h.x  * x0.y;
	g.yz = a0.yz * x12.xz + h.yz * x12.yw;
	return 130.0 * dot(m, g);
}

// lighting
/*float diffuse(vec3 n,vec3 l,float p) {
    return pow(dot(n,l) * 0.4 + 0.6,p);
}

float specular(vec3 n,vec3 l,vec3 e,float s) {    
    float nrm = (s + 8.0) / (3.1415 * 8.0);
    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
}
*/

// random/hash function              
float hash( float n )
{
  	return fract(cos(n)*41415.92653);
}

// 3d random/hash noise function
// src Oceanic by frankenburgh: https://www.shadertoy.com/view/4sXGRM
float noise( vec3 x )
{
	vec3 p  = floor(x);
	vec3 f  = smoothstep(0.0, 1.0, fract(x));
	float n = p.x + p.y*57.0 + 113.0*p.z;

  	return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
	    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),
	    mix(mix( hash(n+113.0), hash(n+114.0),f.x),
	    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
}

float waterHeight( vec2 p )
{
	float smallWaveGain = 0.8;
	float largeWaveGain = 0.05;
	float height = 0.0;

	vec2 shift1 = -0.001*vec2( uTime*160.0*2.0, uTime*120.0*2.0 );
	vec2 shift2 = -0.0015*vec2( uTime*190.0*2.0, uTime*130.0*2.0 );

	float wave = 0.0;

	wave += sin(p.x*0.02+p.y*0.002+shift2.x*3.4)*5.0;
	wave += sin(p.x*0.03+p.y*0.01+shift2.x*4.2)*2.5 ;
	wave *= largeWaveGain;

	wave += (snoise(vec2(p*0.004 + shift1))-.5)*smallWaveGain*0.5;
	wave += (snoise(vec2(p*0.010 + shift1*1.3))-.5)*smallWaveGain*0.15;
	float amp = smallWaveGain;
	float smoothamp = 1.0;

	for (float i=0.0; i<5.0; i+=1.0) {
		float n = (sin(noise(vec3(p*0.01+shift1, uTime*0.2+1000.0))-.5))*amp*1.0;

		// smoothed abs value. Less grainy and smoother waves than abs(n)
		float mu = 0.03*smoothamp;
		abs(n) < mu ? n = n*n/(2.0*mu): n = abs(n)-mu*0.5;
		//n = abs(n); 
		wave -= n;
		amp *= 0.5;
		shift1 *= 1.8;
		p *= m2*0.9;
		smoothamp *= 0.65;
	}

	height += wave;
	return height;
}

void main() {
	vec3 skyColor = vec3(135.0/255.0, 206.0/255.0, 235.0/255.0);
	vec3 opaqueColor = vec3(0.05, 0.15, 0.2); // dark blue

	// parameters in schlicks approximation
	float minOpacity = 0.15;
	float opaqueDepth = 2.0; // depth of the water when it becomes fully opaque
	float minReflectivity = 0.05; // 0.02 for air->water

	vec3 eye = uEyeCoord;
	vec3 viewDirection = normalize (eye - vWorldSpaceCoord.xyz);

	float scale = 40.0;
	float delta = scale/200.0;
	vec2 xDiff = vec2(1.0, 0.0)*delta;
	vec2 yDiff = vec2(0.0, 1.0)*delta;

	vec3 surfaceNormal = normalize(vec3(waterHeight(scale*vWorldSpaceCoord.xz-xDiff) - waterHeight(scale*vWorldSpaceCoord.xz+xDiff), 1.0/scale, waterHeight(scale*vWorldSpaceCoord.xz-yDiff) - waterHeight(scale*vWorldSpaceCoord.xz+yDiff)));
	float cosT1 = abs(dot(viewDirection, surfaceNormal));
	// Reflectance
	float c = 1.0 - cosT1;
	float R = minReflectivity + (1.0 - minReflectivity) * c * c * c * c * c; //Schlick's approximation
	// Water density
	float depth = 1000.0;
	float thickness = depth / max (cosT1, 0.01);
	float dWater = minOpacity + (1.0 - minOpacity) * sqrt (min (thickness / opaqueDepth, 1.0));
	// Premultiply
	vec3 waterColor = opaqueColor * dWater;

	// not correct. I think I need some kind of raymarching to determine the what will be reflected
	vec2 textureOffset = 30.0*normalize(surfaceNormal.xz)*(1.0 - dot(surfaceNormal,vec3(0.0,1.0,0.0)));
	vec3 blah = vModelSpaceCoord;
	blah.xz += textureOffset;
	vec4 vClipReflection = uPMatrix * uReflectionViewMatrix * uMMatrix * vec4(blah, 1.0);
	vec2 vDeviceReflection = vClipReflection.st / vClipReflection.q;
	vec2 vTextureReflection = vec2(0.5, 0.5) + 0.5 * vDeviceReflection;
	vec4 reflectionTextureColor = texture2D (uReflectionTexture, vTextureReflection);

	// Mix sky with reflection from objects
	reflectionTextureColor = vec4((reflectionTextureColor.xyz*reflectionTextureColor.a + skyColor.xyz*(1.0 - reflectionTextureColor.a)), 1.0);

	// Mix reflection with water color
	vec3 color = (1.0 - R) * waterColor + R * reflectionTextureColor.rgb;
	float alpha = R + (1.0 - R) * dWater;

	gl_FragColor = vec4(color, alpha);
}